1.1 여러분이 프로그래밍 언어를 발명한다면?
CPU는 개폐(on-off)만 이해하는 매우 원시적인 기계.

저수준 언어: 천공카드 -> 어셈블리어

고급 프로그래밍 언어: 명령의 규칙과 패턴을 statement(문)으로 -> 중첩된 statement를 syntax(구문)으로 -> syntax를 컴퓨터가 이해할 수 있도록 syntax tree(구문트리)로 준비 -> compiler가 리프노드부터 재귀적으로 기계명령어로 번역

해석형 언어: CPU 형식 별로 다른 기계어를 쓰는 문제가 있음. 마치 영어가 국제 통용어로 사용되듯이 CPU 형식과 무관한 표준 명령어 집합을 만들어 사용하고, CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 따로 준비해서 실행하는 것으로 해결. '모방'한다고 표현한 것은, 표준 명령어로만 실행해도 각 CPU의 특성에 맞는 기계명령어가 실행되는 맥락을 의미한 것. 이러한 CPU 시뮬레이션 프로그램을 가상머신(virtual machie) 혹은 인터프리터(interpreter) 라고 부름.

1.2 컴파일러는 어떻게 작동하는 것일까?
컴파일러는 고수준 언어를 저수준 언어로 번역하는 "프로그램"의 일종.
소스코드를 입력하면 실행 파일을 반환한다. 텍스트 처리 프로그램 이라고 볼 수도 있다.

소스코드에서 어휘 분석(lexical analysis)을 통해 토큰(token)을 추출한다.
    int a = 1;
    int b = 2;
    
    while (a < b)
    {
    	b = b - 1;
    }
	⬇️
    T_Keyword		int
    T_Identifier 	a
    T_Assign		=
    ...
    (각 행이 하나의 토큰을 의미)
코드가 작성된 구문 문법에 따라 토큰을 해석(parsing)한다. 이 과정에서 문법 오류(syntax error)를 검사한다.
예를 들어, while 구문으로 작성된 코드가 있다면 while 키워드의 토큰을 찾으면 다음 토큰은 ( 여야 한다는 전제 하에 해석을 진행.
해석해낸 구조를 토대로 구문 트리를 생성한다. 이렇게 트리를 생성하는 전체 과정을 구문 분석이라고 한다.
생성된 구문트리에 이상이 없는지를 확인하기 위해 의미분석(semantic analysis)을 실행한다. 이 과정에서 컴파일 오류를 검사한다.
예를 들어, 정수와 문자열을 더할 수 없고 비교 좌우에 있는 자료형이 다르면 안된다.
구문트리를 탐색한 결과로 중간코드(IR Code)를 생성하고, 이를 어셈블리어 -> 기계 명령어 의 순서로 변환한다.
(Intermediate Representation Code)
이것은 실제로는 매우 복잡한 과정.

이후에는, 소스코드가 소스파일에 있듯 기계명령어는 대상파일(object file)에 저장되는데, 여러 개의 대상파일을 묶기 위해 링크(link) 라는 작업이 필요.
